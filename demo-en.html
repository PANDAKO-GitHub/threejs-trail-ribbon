<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrailRibbon Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #1a1a2e;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 5px;
        }
        #controls label {
            display: block;
            margin-bottom: 10px;
        }
        #controls input[type="range"] {
            width: 150px;
        }
        #controls input[type="color"] {
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div id="info">
        Move mouse to draw ribbon
    </div>
    <div id="controls">
        <label>
            Width: <input type="range" id="width" min="0.1" max="2" step="0.1" value="0.5">
            <span id="widthValue">0.5</span>
        </label>
        <label>
            Fade Time: <input type="range" id="fadeTime" min="0.5" max="5" step="0.5" value="2">
            <span id="fadeTimeValue">2</span>s
        </label>
        <label>
            Color: <input type="color" id="color" value="#00ffff">
        </label>
        <label>
            <input type="checkbox" id="billboard" checked> Billboard Mode
        </label>
        <label id="normalAngleLabel" style="display: none;">
            Normal Angle: <input type="range" id="normalAngle" min="0" max="360" step="5" value="0">
            <span id="normalAngleValue">0</span>Â°
        </label>
        <label>
            Texture: <input type="file" id="textureFile" accept="image/*" style="width: 140px;">
        </label>
        <button id="clearTexture" style="margin-top: 5px; padding: 3px 8px;">Clear Texture</button>
        <hr style="margin: 10px 0; border-color: #555;">
        <button id="clearRibbon" style="padding: 5px 10px;">Clear Ribbon</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TrailRibbon } from './TrailRibbon.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // OrbitControls setup
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Grid helper
        const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
        scene.add(gridHelper);

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Create ribbon
        let ribbon = new TrailRibbon({
            maxPoints: 200,
            fadeTime: 2.0,
            color: new THREE.Color(0x00ffff),
            billboard: true
        });
        ribbon.setCamera(camera);
        scene.add(ribbon.mesh);

        // Mouse tracking
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();
        let isDrawing = false;
        let lastPoint = null;

        // UI elements
        const widthInput = document.getElementById('width');
        const widthValue = document.getElementById('widthValue');
        const fadeTimeInput = document.getElementById('fadeTime');
        const fadeTimeValue = document.getElementById('fadeTimeValue');
        const colorInput = document.getElementById('color');
        const billboardInput = document.getElementById('billboard');
        const normalAngleInput = document.getElementById('normalAngle');
        const normalAngleValue = document.getElementById('normalAngleValue');
        const normalAngleLabel = document.getElementById('normalAngleLabel');
        const textureFileInput = document.getElementById('textureFile');
        const clearTextureButton = document.getElementById('clearTexture');
        const clearRibbonButton = document.getElementById('clearRibbon');
        const textureLoader = new THREE.TextureLoader();

        widthInput.addEventListener('input', () => {
            widthValue.textContent = widthInput.value;
        });

        fadeTimeInput.addEventListener('input', () => {
            fadeTimeValue.textContent = fadeTimeInput.value;
            recreateRibbon();
        });

        billboardInput.addEventListener('change', () => {
            // Show normal angle slider only when billboard is OFF
            normalAngleLabel.style.display = billboardInput.checked ? 'none' : 'block';
            recreateRibbon();
        });

        normalAngleInput.addEventListener('input', () => {
            normalAngleValue.textContent = normalAngleInput.value;
            ribbon.setNormalAngle(parseFloat(normalAngleInput.value));
        });

        function recreateRibbon() {
            const currentColor = ribbon.color;
            const currentTexture = ribbon.texture;
            scene.remove(ribbon.mesh);
            ribbon.dispose();
            ribbon = new TrailRibbon({
                maxPoints: 200,
                fadeTime: parseFloat(fadeTimeInput.value),
                color: currentColor,
                billboard: billboardInput.checked,
                normalAngle: parseFloat(normalAngleInput.value),
                texture: currentTexture
            });
            ribbon.setCamera(camera);
            scene.add(ribbon.mesh);
        }

        colorInput.addEventListener('input', () => {
            ribbon.setColor(new THREE.Color(colorInput.value));
        });

        textureFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                textureLoader.load(url, (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    ribbon.setTexture(texture);
                    URL.revokeObjectURL(url);
                });
            }
        });

        clearTextureButton.addEventListener('click', () => {
            ribbon.setTexture(null);
            textureFileInput.value = '';
        });

        clearRibbonButton.addEventListener('click', () => {
            ribbon.clear();
            lastPoint = null;
        });

        // Mouse events
        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        document.addEventListener('mousedown', () => {
            isDrawing = true;
            lastPoint = null;
        });

        document.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        // Auto demo circular motion parameters
        let autoTime = 0;
        let autoMode = true;

        document.addEventListener('mousemove', () => {
            autoMode = false;
        });

        // Time management
        const clock = new THREE.Clock();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            if (autoMode) {
                // Auto demo mode: spiral motion
                autoTime += deltaTime;
                const radius = 3 + Math.sin(autoTime * 0.5) * 2;
                const x = Math.cos(autoTime * 2) * radius;
                const y = Math.sin(autoTime * 3) * 1.5 + 2;
                const z = Math.sin(autoTime * 2) * radius;

                const position = new THREE.Vector3(x, y, z);
                const width = 0.3 + Math.sin(autoTime * 5) * 0.2;
                ribbon.addPoint(position, width);
            } else {
                // Mouse tracking mode
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(plane, intersectPoint);

                if (intersectPoint) {
                    // Raise mouse position slightly
                    intersectPoint.y = 1;

                    // Add point only when moved beyond a certain distance
                    if (lastPoint === null || intersectPoint.distanceTo(lastPoint) > 0.1) {
                        ribbon.addPoint(intersectPoint.clone(), parseFloat(widthInput.value));
                        lastPoint = intersectPoint.clone();
                    }
                }
            }

            // Update ribbon (fade out processing)
            ribbon.update(deltaTime);

            controls.update();
            renderer.render(scene, camera);
        }

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
